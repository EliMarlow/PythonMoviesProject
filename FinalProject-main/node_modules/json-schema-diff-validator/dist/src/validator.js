"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fast_json_patch_1 = require("fast-json-patch");
const fs_1 = require("fs");
const jsonpointer = require("json-pointer");
function getData(fileName) {
    return JSON.parse(fs_1.readFileSync(fileName, { encoding: 'utf-8' }));
}
function getSecondLastSubPath(path) {
    const arr = path.split('/');
    return arr[arr.length - 2];
}
function getLastSubPath(path) {
    const arr = path.split('/');
    return arr[arr.length - 1];
}
function validateSchemaCompatibility(originalSchema, changedSchema, opts = {}) {
    const move = 'move';
    const remove = 'remove';
    const replace = 'replace';
    const add = 'add';
    let diff = [];
    const patch = fast_json_patch_1.compare(originalSchema, changedSchema);
    const removed = [];
    const inserted = [];
    patch.forEach(node => {
        const operation = node.op;
        const path = node.path;
        const required = 'required';
        const props = 'properties';
        const defn = 'definitions';
        const isMinItems = /minItems$/.test(path);
        switch (operation) {
            case move:
            case remove:
                if (getSecondLastSubPath(path) === required ||
                    isMinItems) {
                    break;
                }
                /**
                 * Check if the removed node is deprecated
                 */
                const deprecatedItems = opts.deprecatedItems || [];
                const isAnyOfItem = /anyOf\/[\d]+$/.test(path);
                if (isAnyOfItem) {
                    const value = jsonpointer.get(originalSchema, path);
                    if (value.$ref && deprecatedItems.indexOf(getLastSubPath(value.$ref)) !== -1) {
                        break;
                    }
                }
                else {
                    if (deprecatedItems.indexOf(getLastSubPath(path)) !== -1) {
                        break;
                    }
                }
                diff.push(node);
                break;
            case replace:
                const oldValue = jsonpointer.get(originalSchema, path);
                if (isMinItems && oldValue > node.value) {
                    /** skip */
                }
                else {
                    if (!opts.allowReorder) {
                        diff.push(node);
                    }
                    else {
                        removed.push({ name: oldValue, node: node });
                        inserted.push(node.value);
                    }
                }
                break;
            case add:
                const isNewAnyOfItem = /anyOf\/[\d]+$/.test(path);
                const isNewEnumValue = /enum\/[\d]+$/.test(path);
                const pathTwoLastLevels = getSecondLastSubPath(path);
                if (pathTwoLastLevels !== props && pathTwoLastLevels !== defn) {
                    if (isNewAnyOfItem && opts.allowReorder) {
                        inserted.push(node.value.$ref);
                    }
                    else if ((isNewAnyOfItem && opts.allowNewOneOf) ||
                        (isNewEnumValue && opts.allowNewEnumValue)) {
                        // skip this
                    }
                    else {
                        diff.push(node);
                    }
                }
                if (pathTwoLastLevels === required) {
                    diff.push(node);
                }
                break;
            default:
        }
    });
    if (opts.allowReorder) {
        // When reordering is allowed, we want to make sure that any item that
        // was replaced is also inserted somewhere else.
        diff = [
            ...diff,
            ...removed.filter(node => inserted.indexOf(node.name) === -1).map(node => node.node),
        ];
    }
    // tslint:disable-next-line:max-line-length
    assert.strictEqual(diff.length, 0, `The schema is not backward compatible. Difference include breaking change = ${JSON.stringify(diff)}`);
}
exports.validateSchemaCompatibility = validateSchemaCompatibility;
function validateSchemaFiles(file1, file2, opts = {}) {
    const original = getData(file1);
    const changed = getData(file2);
    return validateSchemaCompatibility(original, changed, opts);
}
exports.validateSchemaFiles = validateSchemaFiles;
//# sourceMappingURL=validator.js.map